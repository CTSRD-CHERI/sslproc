/*-
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * Copyright (c) 2021 SRI International
 *
 * This software was developed by SRI International and the University of
 * Cambridge Computer Laboratory (Department of Computer Science and
 * Technology) under DARPA contract HR0011-18-C-0016 ("ECATS"), as part of the
 * DARPA SSITH research programme.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <stdio.h>
#include <unordered_map>

#include "Messages.h"

namespace std
{
	template<>
	struct hash<Message::Type>
	{
		std::size_t operator()(const Message::Type &type) const noexcept
		{
			return static_cast<size_t>(type);
		}
	};
}

class MessageNames
{
public:
	MessageNames();
	~MessageNames() = default;

	const char *lookup(enum Message::Type type) const;

private:
	std::unordered_map<enum Message::Type, const char *> map;
};

MessageNames::MessageNames()
{
#define ADD_MESSAGE(x)				\
	map.emplace(Message::x, __STRING(x))

	ADD_MESSAGE(NOP);
	ADD_MESSAGE(RESULT);

	ADD_MESSAGE(CREATE_COMMAND_CHANNEL);
#ifdef HAVE_COCALL
	ADD_MESSAGE(RETRY);
#else
	ADD_MESSAGE(FORK);
#endif

	ADD_MESSAGE(CREATE_CONTEXT);

	ADD_MESSAGE(CREATE_CONF_CONTEXT);

	ADD_MESSAGE(FREE_CONTEXT);
	ADD_MESSAGE(CTX_SET_OPTIONS);
	ADD_MESSAGE(CTX_CLEAR_OPTIONS);
	ADD_MESSAGE(CTX_GET_OPTIONS);
	ADD_MESSAGE(CTX_CTRL);
	ADD_MESSAGE(CTX_USE_CERTIFICATE_ASN1);
	ADD_MESSAGE(CTX_USE_PRIVATEKEY_ASN1);
	ADD_MESSAGE(CTX_CHECK_PRIVATE_KEY);
	ADD_MESSAGE(CTX_ENABLE_SERVERNAME_CB);
	ADD_MESSAGE(CTX_DISABLE_SERVERNAME_CB);
	ADD_MESSAGE(CTX_ENABLE_CLIENT_HELLO_CB);
	ADD_MESSAGE(CTX_DISABLE_CLIENT_HELLO_CB);
	ADD_MESSAGE(CTX_ENABLE_SRP_USERNAME_CB);
	ADD_MESSAGE(CTX_DISABLE_SRP_USERNAME_CB);
	ADD_MESSAGE(CTX_ENABLE_SESS_CBS);
	ADD_MESSAGE(CTX_DISABLE_SESS_CBS);
	ADD_MESSAGE(CTX_ENABLE_TMP_DH_CB);
	ADD_MESSAGE(CTX_DISABLE_TMP_DH_CB);
	ADD_MESSAGE(CTX_ENABLE_INFO_CB);
	ADD_MESSAGE(CTX_DISABLE_INFO_CB);
	ADD_MESSAGE(CTX_ENABLE_ALPN_SELECT_CB);
	ADD_MESSAGE(CTX_DISABLE_ALPN_SELECT_CB);
	ADD_MESSAGE(CTX_SET_CIPHER_LIST);
	ADD_MESSAGE(CTX_SET_CIPHERSUITES);
	ADD_MESSAGE(CTX_SET_TIMEOUT);
	ADD_MESSAGE(CTX_GET0_CERTIFICATE);
	ADD_MESSAGE(CTX_ENABLE_CLIENT_CERT_CB);
	ADD_MESSAGE(CTX_DISABLE_CLIENT_CERT_CB);
	ADD_MESSAGE(CTX_SET_VERIFY);
	ADD_MESSAGE(CTX_GET_VERIFY_MODE);
	ADD_MESSAGE(CTX_LOAD_VERIFY_LOCATIONS);
	ADD_MESSAGE(CTX_SET_CLIENT_CA_LIST);
	ADD_MESSAGE(CTX_GET_CLIENT_CA_LIST);
	ADD_MESSAGE(CTX_SET_POST_HANDSHAKE_AUTH);
	ADD_MESSAGE(CREATE_SESSION);

	ADD_MESSAGE(FREE_SESSION);
	ADD_MESSAGE(CONNECT);
	ADD_MESSAGE(DO_HANDSHAKE);
	ADD_MESSAGE(ACCEPT);
	ADD_MESSAGE(SHUTDOWN);
	ADD_MESSAGE(READ);
	ADD_MESSAGE(PEEK);
	ADD_MESSAGE(WRITE);
	ADD_MESSAGE(ENABLE_MSG_CB);
	ADD_MESSAGE(DISABLE_MSG_CB);
	ADD_MESSAGE(SET_ACCEPT_STATE);
	ADD_MESSAGE(SET_CONNECT_STATE);
	ADD_MESSAGE(IS_SERVER);
	ADD_MESSAGE(IN_INIT);
	ADD_MESSAGE(IN_BEFORE);
	ADD_MESSAGE(IS_INIT_FINISHED);
	ADD_MESSAGE(GET_SERVERNAME);
	ADD_MESSAGE(GET_SERVERNAME_TYPE);
	ADD_MESSAGE(CTRL);
	ADD_MESSAGE(USE_CERTIFICATE_ASN1);
	ADD_MESSAGE(USE_PRIVATEKEY_ASN1);
	ADD_MESSAGE(CHECK_PRIVATE_KEY);
	ADD_MESSAGE(SET_SHUTDOWN);
	ADD_MESSAGE(GET_SHUTDOWN);
	ADD_MESSAGE(GET_PEER_CERTIFICATE);
	ADD_MESSAGE(GET_VERIFY_RESULT);
	ADD_MESSAGE(SET_VERIFY_RESULT);
	ADD_MESSAGE(GET_VERIFY_MODE);
	ADD_MESSAGE(GET_VERIFY_DEPTH);
	ADD_MESSAGE(SET_VERIFY);
	ADD_MESSAGE(VERIFY_CLIENT_POST_HANDSHAKE);
	ADD_MESSAGE(SET_ALPN_PROTOS);
	ADD_MESSAGE(SET_CIPHER_LIST);
	ADD_MESSAGE(SET_CIPHERSUITES);
	ADD_MESSAGE(SET_SRP_SERVER_PARAM);
	ADD_MESSAGE(GET_SRP_USERNAME);
	ADD_MESSAGE(GET_SRP_USERINFO);
	ADD_MESSAGE(GET_CURRENT_CIPHER);
	ADD_MESSAGE(GET_PENDING_CIPHER);
	ADD_MESSAGE(SET_SESSION_ID_CONTEXT);
	ADD_MESSAGE(CLIENT_VERSION);
	ADD_MESSAGE(VERSION);
	ADD_MESSAGE(SET_SSL_CTX);
	ADD_MESSAGE(GET_CIPHERS);
	ADD_MESSAGE(GET_PEER_CERT_CHAIN);
	ADD_MESSAGE(RENEGOTIATE);
	ADD_MESSAGE(GET_CERTIFICATE);
	ADD_MESSAGE(GET_PRIVATEKEY);
	ADD_MESSAGE(GET_CLIENT_CA_LIST);
	ADD_MESSAGE(STATE_STRING_LONG);
	ADD_MESSAGE(CLIENT_HELLO_GET0_EXT);
	ADD_MESSAGE(GET_SESSION);
	ADD_MESSAGE(SESSION_REUSED);
	ADD_MESSAGE(SET_OPTIONS);
	ADD_MESSAGE(CLEAR_OPTIONS);
	ADD_MESSAGE(GET_OPTIONS);

	ADD_MESSAGE(BIO_READ);
	ADD_MESSAGE(BIO_WRITE);
	ADD_MESSAGE(BIO_CTRL_READ);
	ADD_MESSAGE(BIO_CTRL_WRITE);

	ADD_MESSAGE(MSG_CB);
	ADD_MESSAGE(SERVERNAME_CB);
	ADD_MESSAGE(CLIENT_HELLO_CB);
	ADD_MESSAGE(SRP_USERNAME_CB);
	ADD_MESSAGE(SESS_NEW_CB);
	ADD_MESSAGE(SESS_REMOVE_CB);
	ADD_MESSAGE(SESS_GET_CB);
	ADD_MESSAGE(TMP_DH_CB);
	ADD_MESSAGE(INFO_CB);
	ADD_MESSAGE(ALPN_SELECT_CB);
	ADD_MESSAGE(CLIENT_CERT_CB);
	ADD_MESSAGE(VERIFY_CB);
	ADD_MESSAGE(DEFAULT_PASSWD_CB);
	ADD_MESSAGE(CTX_DEFAULT_PASSWD_CB);

	ADD_MESSAGE(FREE_CONF_CONTEXT);
	ADD_MESSAGE(CONF_CTX_FINISH);
	ADD_MESSAGE(CONF_CTX_SET_FLAGS);
	ADD_MESSAGE(CONF_CMD);
	ADD_MESSAGE(CONF_CMD_VALUE_TYPE);
	ADD_MESSAGE(CONF_CTX_SET_SSL_CTX);

	ADD_MESSAGE(CIPHER_FETCH_INFO);

	ADD_MESSAGE(SESSION_GET_COMPRESS_ID);
	ADD_MESSAGE(SESSION_GET_TIME);
	ADD_MESSAGE(SESSION_GET_ASN1);
	ADD_MESSAGE(SESSION_SET_TIMEOUT);
	ADD_MESSAGE(SESSION_REMOVE_TARGET);

#undef ADD_MESSAGE
}

const char *
MessageNames::lookup(enum Message::Type type) const
{
	const auto it = map.find(type);
	if (it == map.end())
		return (nullptr);
	return (it->second);
}

static MessageNames names;

const char *
Message::typeName(enum Message::Type type)
{
	const char *name = names.lookup(type);
	if (name != nullptr)
		return (name);

	static thread_local char buf[16];
	snprintf(buf, sizeof(buf), "%#x", static_cast<unsigned int>(type));
	return (buf);
}
